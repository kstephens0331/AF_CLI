*** Begin Patch
*** Add File: src/lib/url.ts
+export function getBaseUrl() {
+  if (typeof window !== "undefined") return window.location.origin;
+  return process.env.NEXT_PUBLIC_BASE_URL || "http://localhost:3000";
+}
+export function absoluteUrl(path: string) {
+  const base = getBaseUrl().replace(/\/$/, "");
+  const p = path.startsWith("/") ? path : `/${path}`;
+  return `${base}${p}`;
+}
+

*** End Patch
*** Begin Patch
*** Add File: src/lib/supabase.ts
+import { createClient } from "@supabase/supabase-js";
+
+const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL!;
+const anonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!;
+const serviceRole = process.env.SUPABASE_SERVICE_ROLE; // server-only
+
+export function createAnonClient() {
+  if (!supabaseUrl || !anonKey) throw new Error("Supabase envs missing");
+  return createClient(supabaseUrl, anonKey, { auth: { persistSession: false } });
+}
+
+export function createServerClient() {
+  if (!supabaseUrl || !serviceRole) throw new Error("Supabase service envs missing");
+  return createClient(supabaseUrl, serviceRole, {
+    auth: { persistSession: false },
+    global: { headers: { "X-Server-Env": "true" } },
+  });
+}
+

*** End Patch
*** Begin Patch
*** Add File: src/lib/llm.ts
+export type LLMOpts = {
+  system?: string;
+  temperature?: number;
+  maxTokens?: number;
+  model?: string;
+};
+
+export async function generate(prompt: string, opts: LLMOpts = {}) {
+  const apiKey = process.env.TOGETHER_API_KEY;
+  const model = opts.model || process.env.TOGETHER_MODEL || "meta-llama/Meta-Llama-3.1-70B-Instruct-Turbo";
+  if (!apiKey) throw new Error("TOGETHER_API_KEY missing");
+  const res = await fetch("https://api.together.xyz/inference", {
+    method: "POST",
+    headers: {
+      "Authorization": `Bearer ${apiKey}`,
+      "Content-Type": "application/json"
+    },
+    body: JSON.stringify({
+      model,
+      input: [{ role: "system", content: opts.system || "You are a helpful assistant for medical study content." },
+              { role: "user", content: prompt }],
+      temperature: opts.temperature ?? 0.2,
+      max_tokens: opts.maxTokens ?? 1024,
+      stream: false
+    })
+  });
+  if (!res.ok) throw new Error(`Together API error ${res.status}`);
+  const data = await res.json();
+  const text = data?.output_text || data?.output?.[0]?.content || JSON.stringify(data);
+  return String(text);
+}
+

*** End Patch
*** Begin Patch
*** Add File: src/lib/srs.ts
+export type CardState = {
+  interval_days: number;
+  ease: number;
+  reps: number;
+  lapses: number;
+  due_at: string; // ISO
+};
+
+export function nextReview(state: CardState, grade: 0|1|2|3|4|5, now = new Date()): CardState {
+  let { interval_days, ease, reps, lapses } = state;
+  // bounds
+  ease = Math.max(1.3, Math.min(ease || 2.5, 2.8));
+  if (grade < 3) {
+    lapses += 1;
+    reps = 0;
+    interval_days = 1;
+    ease = Math.max(1.3, ease - 0.2);
+  } else {
+    reps += 1;
+    if (reps === 1) interval_days = 1;
+    else if (reps === 2) interval_days = 6;
+    else interval_days = Math.round(interval_days * ease);
+    ease = Math.min(2.8, ease + (grade === 5 ? 0.05 : 0));
+  }
+  const due = new Date(now.getTime() + interval_days * 24 * 60 * 60 * 1000);
+  return { interval_days, ease, reps, lapses, due_at: due.toISOString() };
+}
+

*** End Patch
*** Begin Patch
*** Add File: src/lib/prompts.ts
+export const mapPrompt = (chunk: string) => `
+You are building med lecture study notes.
+CHUNK:
+${chunk}
+
+Return JSON with { key_points: string[], pearls: string[], pitfalls: string[], tags: string[] }.
+`;
+
+export const reducePrompt = (items: any[]) => `
+You are aggregating mapped items into a study pack.
+Return JSON with { abstract, outline: string[], pearls: string[], cloze: string[], quiz: string[], vignettes: any[] }.
+Items:
+${JSON.stringify(items).slice(0, 4000)}
+`;
+
+export const reportPrompt = (pack: any) => `
+Make a coverage report (JSON) with { objectives: string[], timeline: string[], pitfalls: string[] } for this pack:
+${JSON.stringify(pack).slice(0, 4000)}
+`;
+
+export const vignetteBatchPrompt = (context: string) => `
+Create 5 NBME-style vignettes (JSON list) from:
+${context}
+`;
+
+export const directBatchPrompt = (context: string) => `
+Create 20 direct QA items (JSON list) from:
+${context}
+`;
+

*** End Patch
*** Begin Patch
*** Add File: app/api/blocks/current/route.ts
+import { NextRequest } from "next/server";
+
+export async function POST(req: NextRequest) {
+  try {
+    return Response.json({ ok: true });
+  } catch (e: any) {
+    return Response.json({ error: String(e?.message || e) }, { status: 500 });
+  }
+}
+

*** End Patch
*** Begin Patch
*** Add File: app/api/lecture/upload/route.ts
+import { NextRequest } from "next/server";
+
+export async function POST(req: NextRequest) {
+  try {
+    return Response.json({ ok: true });
+  } catch (e: any) {
+    return Response.json({ error: String(e?.message || e) }, { status: 500 });
+  }
+}
+

*** End Patch
*** Begin Patch
*** Add File: app/api/lecture/summarize/route.ts
+import { NextRequest } from "next/server";
+
+export async function POST(req: NextRequest) {
+  try {
+    return Response.json({ ok: true });
+  } catch (e: any) {
+    return Response.json({ error: String(e?.message || e) }, { status: 500 });
+  }
+}
+

*** End Patch
*** Begin Patch
*** Add File: app/api/lecture/report/route.ts
+import { NextRequest } from "next/server";
+
+export async function POST(req: NextRequest) {
+  try {
+    return Response.json({ ok: true });
+  } catch (e: any) {
+    return Response.json({ error: String(e?.message || e) }, { status: 500 });
+  }
+}
+

*** End Patch
*** Begin Patch
*** Add File: app/api/vignettes/batch/route.ts
+import { NextRequest } from "next/server";
+
+export async function POST(req: NextRequest) {
+  try {
+    return Response.json({ ok: true });
+  } catch (e: any) {
+    return Response.json({ error: String(e?.message || e) }, { status: 500 });
+  }
+}
+

*** End Patch
*** Begin Patch
*** Add File: app/api/directqs/batch/route.ts
+import { NextRequest } from "next/server";
+
+export async function POST(req: NextRequest) {
+  try {
+    return Response.json({ ok: true });
+  } catch (e: any) {
+    return Response.json({ error: String(e?.message || e) }, { status: 500 });
+  }
+}
+

*** End Patch
*** Begin Patch
*** Add File: app/api/material/upload/route.ts
+import { NextRequest } from "next/server";
+
+export async function POST(req: NextRequest) {
+  try {
+    return Response.json({ ok: true });
+  } catch (e: any) {
+    return Response.json({ error: String(e?.message || e) }, { status: 500 });
+  }
+}
+

*** End Patch
*** Begin Patch
*** Add File: app/api/material/generate/route.ts
+import { NextRequest } from "next/server";
+
+export async function POST(req: NextRequest) {
+  try {
+    return Response.json({ ok: true });
+  } catch (e: any) {
+    return Response.json({ error: String(e?.message || e) }, { status: 500 });
+  }
+}
+

*** End Patch
*** Begin Patch
*** Add File: app/api/srs/bootstrap/route.ts
+import { NextRequest } from "next/server";
+
+export async function POST(req: NextRequest) {
+  try {
+    return Response.json({ ok: true });
+  } catch (e: any) {
+    return Response.json({ error: String(e?.message || e) }, { status: 500 });
+  }
+}
+

*** End Patch
*** Begin Patch
*** Add File: app/api/srs/next/route.ts
+import { NextRequest } from "next/server";
+
+export async function POST(req: NextRequest) {
+  try {
+    return Response.json({ ok: true });
+  } catch (e: any) {
+    return Response.json({ error: String(e?.message || e) }, { status: 500 });
+  }
+}
+

*** End Patch
*** Begin Patch
*** Add File: app/api/srs/review/route.ts
+import { NextRequest } from "next/server";
+
+export async function POST(req: NextRequest) {
+  try {
+    return Response.json({ ok: true });
+  } catch (e: any) {
+    return Response.json({ error: String(e?.message || e) }, { status: 500 });
+  }
+}
+

*** End Patch
*** Begin Patch
*** Add File: app/api/coach/next/route.ts
+import { NextRequest } from "next/server";
+
+export async function POST(req: NextRequest) {
+  try {
+    return Response.json({ ok: true });
+  } catch (e: any) {
+    return Response.json({ error: String(e?.message || e) }, { status: 500 });
+  }
+}
+

*** End Patch
*** Begin Patch
*** Add File: app/api/coach/answer/route.ts
+import { NextRequest } from "next/server";
+
+export async function POST(req: NextRequest) {
+  try {
+    return Response.json({ ok: true });
+  } catch (e: any) {
+    return Response.json({ error: String(e?.message || e) }, { status: 500 });
+  }
+}
+

*** End Patch
*** Begin Patch
*** Add File: supabase/migrations/0001_init.sql
+-- 0001_init.sql
+create schema if not exists public;
+
+-- Tables
+create table if not exists public.blocks (
+  id uuid primary key default gen_random_uuid(),
+  user_id uuid not null,
+  name text not null,
+  start_date date not null,
+  end_date date not null,
+  created_at timestamp with time zone default now()
+);
+
+create table if not exists public.lectures (
+  id uuid primary key default gen_random_uuid(),
+  user_id uuid not null,
+  title text not null,
+  transcript jsonb,
+  created_at timestamp with time zone default now()
+);
+
+create table if not exists public.lecture_packs (
+  id uuid primary key default gen_random_uuid(),
+  user_id uuid not null,
+  lecture_id uuid references public.lectures(id) on delete cascade,
+  summary jsonb,
+  report jsonb,
+  created_at timestamp with time zone default now()
+);
+
+create table if not exists public.materials (
+  id uuid primary key default gen_random_uuid(),
+  user_id uuid not null,
+  title text not null,
+  outline jsonb,
+  content text,
+  created_at timestamp with time zone default now()
+);
+
+create table if not exists public.material_packs (
+  id uuid primary key default gen_random_uuid(),
+  user_id uuid not null,
+  material_id uuid references public.materials(id) on delete cascade,
+  items jsonb,
+  created_at timestamp with time zone default now()
+);
+
+create table if not exists public.cards (
+  id uuid primary key default gen_random_uuid(),
+  user_id uuid not null,
+  source_kind text not null,
+  source_id uuid,
+  front text not null,
+  back text not null,
+  tags text[],
+  interval_days int default 0,
+  ease float default 2.5,
+  reps int default 0,
+  lapses int default 0,
+  due_at timestamptz default now(),
+  created_at timestamptz default now()
+);
+
+create table if not exists public.reviews (
+  id uuid primary key default gen_random_uuid(),
+  user_id uuid not null,
+  card_id uuid references public.cards(id) on delete cascade,
+  grade int not null,
+  reviewed_at timestamptz default now()
+);
+
+-- RLS
+alter table public.blocks enable row level security;
+alter table public.lectures enable row level security;
+alter table public.lecture_packs enable row level security;
+alter table public.materials enable row level security;
+alter table public.material_packs enable row level security;
+alter table public.cards enable row level security;
+alter table public.reviews enable row level security;
+
+create policy owner_blocks on public.blocks for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
+create policy owner_lectures on public.lectures for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
+create policy owner_lecture_packs on public.lecture_packs for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
+create policy owner_materials on public.materials for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
+create policy owner_material_packs on public.material_packs for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
+create policy owner_cards on public.cards for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
+create policy owner_reviews on public.reviews for all using (auth.uid() = user_id) with check (auth.uid() = user_id);
+

*** End Patch
*** Begin Patch
*** Add File: supabase/seed.sql
+-- supabase/seed.sql
+-- (Optional) example inserts (commented for safety)
+-- insert into public.blocks (user_id, name, start_date, end_date)
+-- values ('00000000-0000-0000-0000-000000000000','Example 8-week block', now()::date, (now() + interval '56 days')::date);
+

*** End Patch
*** Begin Patch
*** Add File: services/transcriber/package.json
+{
+  "name": "transcriber",
+  "private": true,
+  "type": "module",
+  "main": "index.js",
+  "scripts": {
+    "start": "node index.js"
+  }
+}
+

*** End Patch
*** Begin Patch
*** Add File: services/transcriber/index.js
+import express from "express";
+import multer from "multer";
+
+const app = express();
+const upload = multer({ storage: multer.memoryStorage() });
+
+app.post("/transcribe", upload.single("file"), async (req, res) => {
+  // Mock transcription for now; can be replaced with Faster-Whisper later.
+  const name = req.file?.originalname || "audio";
+  res.json({
+    ok: true,
+    file: name,
+    duration_sec: 300,
+    segments: [
+      { start: 0, end: 60, text: "Intro / objectives." },
+      { start: 60, end: 180, text: "Core physiology." },
+      { start: 180, end: 300, text: "Path and pearls." }
+    ]
+  });
+});
+
+const port = Number(process.env.PORT || 8081);
+app.listen(port, () => console.log(`Transcriber listening on :${port}`));
+

*** End Patch
*** Begin Patch
*** Add File: services/ingestor/package.json
+{
+  "name": "ingestor",
+  "private": true,
+  "type": "module",
+  "main": "index.js",
+  "scripts": {
+    "start": "node index.js"
+  }
+}
+

*** End Patch
*** Begin Patch
*** Add File: services/ingestor/index.js
+import express from "express";
+import multer from "multer";
+
+const app = express();
+const upload = multer({ storage: multer.memoryStorage() });
+
+async function extractPdf(buffer) {
+  try {
+    const { default: pdfParse } = await import("pdf-parse");
+    const data = await pdfParse(buffer);
+    return { kind: "pdf", outline: [], text: data.text || "" };
+  } catch {
+    return { kind: "pdf", outline: [], text: "" };
+  }
+}
+
+app.post("/extract", upload.single("file"), async (req, res) => {
+  const file = req.file;
+  if (!file) return res.status(400).json({ error: "file missing" });
+  const mimetype = file.mimetype || "";
+  let out = { kind: "unknown", outline: [], text: "" };
+
+  if (mimetype.includes("pdf")) {
+    out = await extractPdf(file.buffer);
+  } else if (mimetype.includes("text") || file.originalname?.endsWith(".txt")) {
+    out = { kind: "txt", outline: [], text: file.buffer.toString("utf8") };
+  } else {
+    out = { kind: "bin", outline: [], text: "" };
+  }
+
+  res.json({ ok: true, ...out });
+});
+
+const port = Number(process.env.PORT || 8082);
+app.listen(port, () => console.log(`Ingestor listening on :${port}`));
+

*** End Patch